cose da fare:
    X !!!come mai archivio non termina!!!
    readme
    X ogni stringa che leggo la metto in una lista e poi dealloco quella
    X levare la free in crea_entry e metterla in writersbody e readersbody
    X mettere la write al posto di fprintf in SIGINT
    X ridefinisci makefile pk gli eseguibili si devono chiamare archivio, client1 e client2
    X se ho errore in connessione, fai unlink pipe
    X a capolettore e caposcrittore passa numw e numr, non puntatore a questi variabili
    X NUMERO DI LETTORI E SCRITTORI È INVERTITO, LI PASSO MALE AD ARCHIVIO.C
    X cambia decodifica 0 e 1 in ricezione socket, rendila uguale alle altre
    nel makefile devono essere eliminati i file oggetto generati
    X metti le costanti in xerrori.h
    È vero che una volta ricevuto SIGTERM devono essere bloccati tutti gli altris segnali?
    X FORSE SERVE server.shutdown(socket.SHUT_RDONLY)? no perché a client2 viene inviato il nro di sequenze ricevute
    X dopo la creazione delle pipe puoi fare tutto un blocco try except e fare l'unlink delle pipe per ogni errore
    X su server.py ho levato import time

PROBABILE CI SIA UN DEADLOCK IN CAPOWRITERSBODY E WRITERSBODY. no. una volta hanno terminato tutti gli scrittori 
ma cmq il programma non terminava

COSE ALLOCATE:
482, MAIN :   int hashtable = hcreate(Num_elem);
    hdestroy();
109, *CREA_ENTRY:   e->key = strdup(s); // salva copia di s
    distruggi entry
111, *CREA_ENTRY:   e->data = malloc(sizeof(coppia));
    distruggi entry
121: AGGIUNGI:   ENTRY *e = crea_entry(s, 1);
    distruggi entry
185: CAPOWRITERSBODY:     char *s= malloc(sizeof(char)*(lunghezza + 1));
    char *deallocami = s;
    free(deallocami);
203: CAPOWRITERSBODY:     a->bufferw[ppindex %PC_buffer_len] =strdup(token);
    aggiungi
264: WRITERSBODY:     aggiungi(s);
    free(s);
297: CAPOREADERBODY:     char *s = malloc(sizeof(char)*(lunghezza+1));
    char *deallocami = s;
    free(deallocami);
314, CAPOREADERBODY:       a->bufferr[ppindex %PC_buffer_len] =strdup(token);
    conta

TUTTI I BLOCCHI VENGONO LIBERATI SE HO 129 ABACO E NON 130
abaco viene distrutto più volte, quindi forse viene aggiunto ogni volta che faccio crea_entry? 
no pk nn sta nel codice e poi mancano solo 4 free
